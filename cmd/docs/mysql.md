### 一条select语句执行的流程
![mysql workflow](./assets/sqlflow.png)
mysql分为server层和存储引擎层
#### server层
- 连接器  

负责跟客户端建立连接、获取权限、管理连接.使用`show processlist`查看连接状态.mysql建立连接的过程比较复杂,所以在使用中尽量减少
连接的动作即尽量使用长连接.但是全部使用长连接可能会导致mysql内存涨的特别快导致OOM.解决这种问题主要有两种办法:
1、定期断开长连接
2、在mysql5.7以后, 每次执行完一个比较大的操作可以,可以通过执行mysql_reset_connection来重新初始化连接资源
- 查询缓存

连接建立以后就可以执行select语句了, 执行逻辑就会来到第二部: 查询缓存. mysql拿到查询请求以后会先查询缓存之前是不是执行过这条语句.
之前执行过的语句及其结果可能以key-value对的形式被直接缓存在内存中(对于更新频繁的数据库来讲,查询缓存的失败率非常高.更新导致缓存失效)
- 分析器

先做词法分析, 在做语法分析
- 优化器 

对分析器的结果做语法优化,e.g. 有多个索引时先使用哪个索引,一个语句有多表关联的时候决定各个表的连接顺序
- 执行器

通过分析器知道了要做什么,通过优化器知道了怎么做,于是就进入了执行器,开始执行语句。调用存储引擎接口
#### 存储引擎层
负责数据的存储和提取, 支持InnoDB、MyISAM、Memory

### update语句流程
update同样会经过select的整个流程,不过进行update操作时会涉及到redolog(重做日志)、binlog(归档日志)
#### redolog

redolog主要在存储层(为InnoDB特有日志),当有更新语句执行时mysql并不是马上进行磁盘IO操作而是理由WAL技术
将更新语句记录在日志中并更新内存,等到合适的时候再将记录更新到磁盘,而这个操作往往是系统比较空闲的时候执行。
redolog的文件块大小是固定的,如果redolog写满了,则会进行主动同步到磁盘.有了redolog就可以保证数据库发生
重启也不会导致提交记录丢失
#### binlog

binlog属于server层日志,所有引擎都可以使用.为逻辑日志,记录的是这个语句的原始逻辑

### 事务
提到事务就会想到事务的特性,ACID(原子性、一致性、隔离性、持久性),隔离的越严实效率越低。
#### 隔离性
事务隔离级别包含:
1、读未提交  一个事务还没提交,它做的变动就能被其他事务看到
2、读提交  一个事务提交以后,它做的变动才会被其他事务看到
3、可重复读  一个事务执行过程中看到的数据总是跟这个事务启动的时候看到的数据是一致的,在可重复读隔离级别下,未提交变更时其他事务也是不可见的
4、串行化  写会加写锁,读会加读锁.当出现读写锁冲突时,后访问的事务必须等前一个事务执行完成才能继续执行

### mysql
- mysql日志组成
1. redo log 重做日志, 记录更新操作 (存储引擎层)
2. binlog 记录逻辑操作 (Server层)

- 索引
1. 主键索引
叶子节点存的是数据行

2. 普通索引
叶子节点存储的为主键,通过普通索引查询行需要回表。普通索引--> 主键索引 --> 数据行

3. 覆盖索引
通过查询普通索引直接获取到主键

4. 最左前缀

5. 索引下推
可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数

6. 普通索引唯一索引选择
一般情况下选择普通索引，性能主要区分在更新操作(普通索引有change buffer)

- sort
排序时会为每个线程分配一块内存sort_buffer用于排序

1. 全字段排序
当sort_buffer小于排序内容时会利用磁盘临时文件排序。根据条件从行中查询出所有需要数据排序

2. rowid排序
只有排序的列和主键, 根据条件从行中只查询需要的列和主键进行排序，排序后再做一次回表操作

#### 为什么同样的逻辑性能差异很大
下面的情况都是针对索引失败导致的
1. 对索引字段使用函数操作可能导致索引失效
2. 隐式的数据类型转换
3. like中%在前面可能导致索引失败

## 集群模式
### 主从模式
1. 属于弱一致性
- 需要解决读写分离逻辑
- 主从同步可能会失败

2. 主从复制原理
- master将数据改变记录到二进制日志(binary log)
- slave将master中的binary log event拷贝到它的中继日志
- slave重做中继日志中的事件,将改变反应到它自己的数据

3. 主从配置需要注意的地方
- 主DB server和从DB server数据库版本要一致
- 主DB server和从DB server的基础数据要一致
- 主DB server需要开启二进制日志,主DB server和从DB server的server_id都必须唯一

### PXC模式
与主从模式不同, PXC在中间件中可以对多个mysql进行读写操作。但是每个mysql实例上一层都有一个PXC集群。PXC解决了强一致性问题
1. 性能比主从低 但是数据安全
2. PXC只支持Innodb模式
3. 节点越多PXC同步越慢
4. 保证PXC集群主机的硬件配置一致,不然配置低的会拖慢整个集群数据复制的进度

### 混合架构
根据不同需求可以搭建混合架构,通过中间件选择不同逻辑

### 二进制日志文件(binlog)记录格式(binlog_format)
1. statement-based replication(SBR) 基于SQL语句的复制
缺点:
使用函数时可能导致数据不一致
优点:
binlog数量较少,减少IO操作提高性能

2. row-based replication (RBR)基于行的复制,记录每条数据的变化
缺点:
产生大量日志,尤其是alert table的时候会让日志暴涨
优点:
不会出现数据不一致问题

3. MIXED模式,混合模式
基于SBR、RBR做混合模式处理

> 主从复制模式时重启master可能导致slave同步不了数据,需要冲洗配置slave的binlog位置和文件名

### PXC集群方案和Replication区别
1. PXC集群所有节点可读可写。Replication从节点不能写入,因为主从同步是单向的,无法从slave向master同步
2. PXC同步机制是同步进行的(强一致性)。Replication是异步进行的,从节点如果停止同步依然可以向主节点同步数据正确返回,造成主从数据不一致
3. PXC是牺牲性能保证数据一致性,Replication在性能上是高于PXC的。两者用途不一样,PXC用于重要信息存储,例如:订单、用户信息等。Replication
用于一般信息存储,能够容忍数据丢失,例如:购物车、用户行为日志
### MyCat
- 数据分片
- 读写分离