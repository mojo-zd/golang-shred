### 为什么协程比线程更轻量级
1. 协程运行在用户态,而线程运行在内核态需要进行特权模式切换(用户态和内核态的切换)
2. 协程运行时候所需资源更少, 内存2kb、CPU切换时间更短

### golang语法糖
#### 短变量和var申明
- `:=`短变量只能在函数内部申明,不能作用于全局变量初始化和申明
#### `...`可变参数
- 可变参数必须位于函数尾部
- 可变参数被当做切片来处理
- 函数调用时可变参数可以不填
- 函数调用时可变参数可以为切片

### goroutine调度器
线程数越多意味着操作系统不断切换线程,频繁的上下文切换成为性能瓶颈。go提供一种机制可以在线程中实行调度, 上下文切换更轻量从而达到减少
线程数量,而并发数量并不少的效果。
G: 即go协程, 每个go关键字都会创建一个协程
P: 处理器, 包含运行go代码的必要资源, 也有调度goroutine的能力。runtime.GOMAXPROCS()设置最大的P, 一般为CPU核数。P可以调度G交由M
执行,其中M就是操作系统的线程。
M: 工作线程, 在go中称为Machine

#### goroutine的调度策略
- 队列轮转
每个P维护一个G队列, 不考虑G进入系统调用或者IO操作的情况下, P周期性的将G调度到M中执行,执行一小段时间将上下文保存下来然后将G放到尾部队列,
并重新取出一个G进行调度

- 系统调用
P默认等于CPU核数,每个M必须有一个P才可以执行G, 一般情况下M的个数会略大于P的个数,多出来的M会在G产生系统调用的时候发挥作用。类似线程池,go
也提供了一个M的线程池。当进行系统调用的G执行完毕时:
1. 如果有空闲的P,则获取一个P继续执行G
2. 如果没有空闲的P,则把G放入全局队列,等待被其他的P调度

- 工作量窃取
空闲的P会从其他P中的队列中窃取工作量进行G的调度,一般窃取量为队列的一半

#### 如何将golang源码转为汇编指令
go build -gcflags -S main.go

### `new` 和 `make`的区别
`make`只针对`map`、`slice`、`chan`类型,返回引用本身并初始化内部结构
`new`分配类型所需空间并返回引用地址, 可以通过初始化字面量的方式代替


#### 如何节省内存
1. 数据结构层面
2. 定义数据类型(如果能用局部变量尽量使用局部变量)
3. 避免闭包中延长变量的生命周期

#### 编译原理


#### 逃逸分析
逃逸分析阶段是在编译阶段完成,逃逸情况:
- 返回变量的指针
- 超出栈空间大小
- 动态类型逃逸, 很多函数参数类型为interface类型,编译期间很难确定参数类型,也会产生逃逸
- 闭包引用对象逃逸

闭包可能会导致变量从栈上逃逸到堆上，给GC造成压力。可以通过编译参数-gcflag=-m. e.g.
```
func myFunc() func() int {
    foo := 0
    return func () int {
        foo++
        return foo
    }
}

bar := myFunc()
val1 := bar() // 1
val2 := bar() // 2
// 由于闭包导致foo的生命周期被延长，从栈移到堆上了
```

#### 锁
Once.Do实现原理, 采用atomic进行原子操作
1. Mutex互斥锁 当一个goroutine获取锁后其他goroutine就只能等待锁被释放才能进行操作
2. RWMutex读写锁，多个goroutine可同时获得读锁，但此时不能被写入。写锁会阻止任何读写操作，被当前写独占

#### chan
不管是否带有缓冲都是进行FIFO的原则

#### 值与指针
golang中函数的参数传递其实是值传递, 是对原有数据的一份拷贝。如果参数传递的是一个指针，则传递的是这个指针的拷贝
> map, chan通过make以后其实返回的是*hmap、*hchan，所以在通过参数传递以后对map的修改会反应到外部
> slice中元素指向是的data的指针,但是永远修改不了len和cap，因为他们是属于值拷贝。如果要修改需要传入*slice

#### 工具
- golint静态代码检查工具
- golangci-lint定制化检查

#### 小技巧
- 运行除_test.go以外的所有go文件
```
go run $(ls -1 *.go | grep -v _test.go)
```